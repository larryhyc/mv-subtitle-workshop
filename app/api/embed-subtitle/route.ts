import { NextResponse } from 'next/server';
import { writeFile, unlink, mkdir } from 'fs/promises';
import { join } from 'path';
import ffmpeg from 'fluent-ffmpeg';
import fs from 'fs';

// --- CONFIGURATION START ---
// Serverless 环境中唯一保证可写入的目录
const TEMP_DIR = '/tmp';
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 最大 100MB
// --- CONFIGURATION END ---

export const dynamic = 'force-dynamic'; // 确保动态路由
export const maxDuration = 300; // 允许最大 5 分钟的执行时间 (取决于部署平台)

// 安全清理文件工具函数
const safeUnlink = async (path: string | null) => {
  if (!path) return;
  try {
    await unlink(path);
  } catch (e) {
    console.warn(`清理文件失败: ${path}`, e);
  }
};

// --- 时间格式化和解析函数 ---

// 格式化时间为 ASS 格式 (h:mm:ss.cc)
const formatTimeAss = (ms: number): string => {
  // ASS 使用百分之一秒 (centiseconds)
  const cs = Math.floor(ms / 10) % 100;
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60; // 格式：h:mm:ss.cc
  return `${hours}:${String(minutes).padStart(2, '0')}:${String(
    seconds
  ).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
};

// 解析 .lrc 文件，提取歌词和开始时间 (毫秒)
const parseLrc = (content: string): { startTime: number; text: string }[] => {
  const lines = content.split('\n');
  const result: { startTime: number; text: string }[] = []; // 匹配 [mm:ss.xx] 或 [m:ss.xxx] 等格式的时间戳
  const timeRegex = /^\[(\d{1,2}):(\d{2})(?:\.(\d{1,3}))?\](.*)/;

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) continue;

    const match = trimmedLine.match(timeRegex);

    if (match) {
      const [, mm, ss, msStr, text] = match; // 处理毫秒：如果不存在则为 0，如果只有两位则补齐三位
      const ms = msStr ? parseInt(msStr.padEnd(3, '0').substring(0, 3)) : 0;

      const startTime = parseInt(mm) * 60 * 1000 + parseInt(ss) * 1000 + ms;

      const cleanText = text.trim();
      if (cleanText) {
        result.push({ startTime, text: cleanText });
      }
    }
  }

  return result
    .filter((line) => line.startTime >= 0) // 过滤掉元数据行 (如 [ti:] 它们startTime=0)
    .sort((a, b) => a.startTime - b.startTime);
};

// --- LRC 转 ASS KTV 样式函数 ---

const lrcToAss = (lrcLines: { startTime: number; text: string }[]): string => {
  // ASS 文件头部和样式定义
  // MarginV: Active (居底 150)，NextLine (居上 50)
  // PrimaryColour 是高亮色 (Active: 黄色 &H00FFFF00)
  // PrimaryColour 是预备色 (NextLine: 灰色 &H00AAAAAA)
  const ASS_HEADER = `
[Script Info]
; Script generated by TempoTune / MV 字匠
Title: KTV Subtitles
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Active, Arial, 48, &H00FFFF00, &H000000FF, &H00000000, &H00000000, 1, 0, 0, 0, 100, 100, 0, 0, 1, 2, 2, 2, 10, 10, 40, 1
Style: NextLine, Arial, 40, &H00AAAAAA, &H000000FF, &H00000000, &H00000000, 1, 0, 0, 0, 100, 100, 0, 0, 1, 2, 2, 2, 10, 10, 20, 1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  let assContent = ASS_HEADER;

  lrcLines.forEach((line, index) => {
    const nextLine = lrcLines[index + 1];
    const startMs = line.startTime;
    const cleanText = line.text.replace(/[<>]/g, '').trim();

    if (!cleanText) return; // 1. 当前高亮行 (Active Line) - 居底

    const activeEndMs = nextLine ? nextLine.startTime : startMs + 3000;
    const activeStartTime = formatTimeAss(startMs);
    const activeEndTime = formatTimeAss(activeEndMs); // Layer 0: 当前正在唱的歌词，高亮显示
    assContent += `Dialogue: 1,${activeStartTime},${activeEndTime},Active,,0,0,0,,${cleanText}\n`; // 2. 下句预备行 (Next Line) - 居上
    if (nextLine) {
      const nextLineText = nextLine.text.replace(/[<>]/g, '').trim(); // 下一句预备在当前行开始时显示
      const nextLineStartTime = activeStartTime; // 下一句预备在它自己开始唱之前结束
      const nextLineEndTime = formatTimeAss(nextLine.startTime); // Layer 1: 下一句歌词，暗色显示，MarginV设置为 50 (偏上)

      assContent += `Dialogue: 1,${nextLineStartTime},${nextLineEndTime},NextLine,,0,0,100,,${nextLineText}\n`;
    }
  });

  return assContent;
};

// --- Next.js POST API Route ---

export async function POST(request: Request) {
  // 声明文件路径变量，用于清理
  let videoPath: string | null = null;
  let assPath: string | null = null;
  let outputPath: string | null = null;

  try {
    const formData = await request.formData();
    const videoFile = formData.get('videoFile') as File;
    const subtitleFile = formData.get('subtitleFile') as File;

    if (!videoFile || !subtitleFile) {
      return NextResponse.json(
        { error: '缺少视频或字幕文件' },
        { status: 400 }
      );
    } // 检查文件大小

    if (videoFile.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        {
          error: `视频文件过大，最大支持 ${Math.round(
            MAX_FILE_SIZE / 1024 / 1024
          )}MB`,
        },
        { status: 400 }
      );
    } // 确保临时目录存在

    await mkdir(TEMP_DIR, { recursive: true }); // 生成唯一文件名

    const fileId =
      Date.now() + '_' + Math.random().toString(36).substring(2, 15);

    videoPath = join(TEMP_DIR, `video_${fileId}.mp4`);
    assPath = join(TEMP_DIR, `subtitle_${fileId}.ass`);
    outputPath = join(TEMP_DIR, `output_${fileId}.mp4`); // 1. 保存视频文件

    const videoBuffer = await videoFile.arrayBuffer();
    await writeFile(videoPath, Buffer.from(videoBuffer)); // 2. 处理 LRC 并保存为 ASS

    const lrcContent = await subtitleFile.text();
    const lrcLines = parseLrc(lrcContent);

    if (lrcLines.length === 0) {
      throw new Error('字幕文件格式错误或无有效歌词');
    }

    const assContent = lrcToAss(lrcLines);
    await writeFile(assPath, assContent, 'utf8');

    console.log('LRC to ASS conversion successful.'); // 3. FFmpeg 视频处理
    await new Promise((resolve, reject) => {
      // 路径转换为 FFmpeg 兼容的斜杠格式
      const videoPathEscaped = videoPath!.replace(/\\/g, '/');
      const assPathEscaped = assPath!.replace(/\\/g, '/');
      const outputPathEscaped = outputPath!.replace(/\\/g, '/');

      const command = ffmpeg(videoPathEscaped) // 使用 ASS 滤镜，它会处理 ASS 文件中的样式和定位
        .outputOptions('-vf', `ass=${assPathEscaped}`)
        .outputOptions('-c:v', 'libx264')
        .outputOptions('-c:a', 'copy') // 保持音频流不变
        .outputOptions('-preset', 'fast')
        .outputOptions('-crf', '25') // 质量设置
        .outputOptions('-y');

      command
        .save(outputPathEscaped)
        .on('end', () => {
          resolve(null);
        })
        .on('error', (err: any) => {
          console.error('FFmpeg error:', err.message);
          reject(
            new Error(
              `视频处理失败，请确认FFmpeg是否可用。错误: ${err.message}`
            )
          );
        });
    }); // 4. 返回处理后的视频文件流

    const stat = fs.statSync(outputPath!);
    const stream = fs.createReadStream(outputPath!);
    return new NextResponse(stream as any, {
      headers: {
        'Content-Type': 'video/mp4',
        'Content-Disposition': `attachment; filename="mv_ktv_subs_${fileId}.mp4"`,
        'Content-Length': stat.size.toString(),
      },
    });
  } catch (error: any) {
    console.error('Processing Error:', error.message);
    let errorMessage = '内部服务器错误，视频处理失败。';
    if (error.message.includes('FFmpeg')) {
      errorMessage = '视频处理服务不可用，请联系管理员。';
    } else if (error.message.includes('字幕文件格式错误')) {
      errorMessage = 'LRC 歌词文件格式无效或为空。';
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    // 5. 清理临时文件
    await Promise.all([
      safeUnlink(videoPath),
      safeUnlink(assPath),
      safeUnlink(outputPath),
    ]);
    console.log('Temporary files cleaned up.');
  }
}
